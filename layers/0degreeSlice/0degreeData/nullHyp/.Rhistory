}
xline(fundFreq*c(1,2,3,4,5), col = "tomato", lty=3)
##find the harmonics
for(j in 1:5){
for(i in 1:length(Fr)){
ifelse(all.equal(fundFreq*j, Fr[i], tol = 0.05)==TRUE, findHarmonic <- c(findHarmonic, P[i]),  NA)
}
}
harmonicSignalsNull <- c(harmonicSignalsNull, sum(findHarmonic)/sum(P))
}
}
boxplot(harmonicSignalsNull)
setwd("C:/Users/barna/Documents/Coupons/nlsAxis/couponCaseStudies/caseStudyData/cropped")
Zero <- which(couponCov$polarAngle == 0)
setwd("C:/Users/barna/Documents/Coupons/nlsAxis/datasets")
load("couponCov.rda")
setwd("C:/Users/barna/Documents/Coupons/nlsAxis/couponCaseStudies/caseStudyData/cropped")
Zero <- which(couponCov$polarAngle == 0)
numCoupons <- length(Zero)
realSignals <- vector()
for(n in Zero){
print(n)
load(paste0("nlsCoupon", n, ".rda"))
# center the coupon
centerCoupon <- cbind(scale(newCoupon[,1], center = TRUE, scale = FALSE),
scale(newCoupon[,2], center = TRUE, scale = FALSE),
newCoupon[,3])
h<-hist(~newCoupon[,3], w=5, plot = FALSE)
histSave <- rbind(h$counts, h$mids)
threshold <- 5
influence <- 0
xGrid <- seq(min(histSave[2,]), max(histSave[2,]), length.out = length(histSave[1,]))
lowpass <- splint(histSave[2,], histSave[1,], xGrid, lambda = 50)
frDt <- fft(histSave[1,]-lowpass)
Dtlen <- length(histSave[1,])
Fr <- (1:Dtlen/Dtlen)[1:(Dtlen/2)]
P <- (Mod(2*frDt/Dtlen)^2)[1:(Dtlen/2)]
plot(Fr,P,type="l", main = paste0(n))
lag <- length(Fr)/10
peak <- findFreq(P,lag,threshold,influence)
ind <- which(peak$signals==1)
Ppeaks <- P[ind]
Frpeaks <- Fr[ind]
# fundFreq <- Frpeaks[which.max(Ppeaks)]
# findHarmonic <- vector()
#
#
# ##check for lowest freq (i.e. fundamental frequency)
#
# for(j in c(1/4,1/3,1/2,2,3,4,5)){
#   for(i in 1:length(Frpeaks)){
#     ifelse(all.equal(fundFreq*j, Frpeaks[i], tol = 0.01)==TRUE,  fundFreq <- c(fundFreq,Frpeaks[i]),  NA)
#   }
# }
#
# xline(fundFreq, col = "grey", lty=3)
#
# fundFreq <- min(fundFreq)
#
# xline(fundFreq, col = "violetred1", lty=3)
#
# ##find the harmonics
# for(j in 1:5){
#   for(i in 1:length(Fr)){
#     ifelse(all.equal(fundFreq*j, Fr[i], tol = 0.01)==TRUE,  findHarmonic <- c(findHarmonic, P[i]),  NA)
#   }
# }
findHarmonic <- vector()
origFreq <- Frpeaks[which.max(Ppeaks)]
for(j in c(1,1/2,1/3,1/4,1/5)){
fundFreq <- origFreq*j
if(fundFreq <= .15){break}
}
xline(fundFreq*c(1,2,3,4,5), col = "tomato", lty=3)
##find the harmonics
for(j in 1:5){
for(i in 1:length(Fr)){
ifelse(all.equal(fundFreq*j, Fr[i], tol = 0.05)==TRUE, findHarmonic <- c(findHarmonic, P[i]),  NA)
}
}
realSignals <- c(realSignals, sum(findHarmonic)/sum(P))
}
layeredCoupons <- harmonicSignals
nullCoupons <- c(harmonicSignalsNull, rep(NA, length(layeredCoupons)-length(nullCoupons)))
realCoupons <- c(realSignals, rep(NA, (length(nullCoupons)-length(realSignals))))
harmonicSignalsNull <- c(harmonicSignalsNull, sum(findHarmonic)/sum(P))
nullCoupons <- c(harmonicSignalsNull, rep(NA, length(layeredCoupons)-length(nullCoupons)))
nullCoupons <- c(harmonicSignalsNull, rep(NA, length(layeredCoupons)-length(harmonicSignalsNull)))
realCoupons <- c(realSignals, rep(NA, (length(nullCoupons)-length(realSignals))))
dat <- cbind(nullCoupons, realCoupons)
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
dat <- cbind(dat, layeredCoupons)
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
t.test(nullCoupons, realCoupons)
t.test(harmonicSignals, realCoupons)
source('~/Coupons/layers/0degreeSlice/testLayers0.R', echo=TRUE)
setwd("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData")
n=59.329
source('~/Coupons/layers/0degreeSlice/testLayers0.R', echo=TRUE)
source('~/Coupons/layers/0degreeSlice/nullHypothesis0.R', echo=TRUE)
source('~/Coupons/layers/0degreeSlice/testRealCoupons0.R', echo=TRUE)
?all.equal
source('~/Coupons/layers/0degreeSlice/testLayers0.R', echo=TRUE)
source('~/Coupons/layers/0degreeSlice/testLayers0.R', echo=TRUE)
order(harmonicSignals)
harmonicSignals[order(harmonicSignals)]
all.equal(fundFreq*j, Fr[i], tol = 0.05)
redo <- order(harmonicSignals)[1:20]
library(conicfit)
library(rgl)
numLayer <- seq(40,60,length.out = 150)
for(l in numLayer[redo]){
z = seq(0,4000,by = l)
y = rep(0, length(z))
x = y
a = 814  #radius
pts <- matrix(NA, nrow = 25, ncol = 3)
pts[,1:2] <- calculateEllipse(x[1],y[1],a,a, steps = 25, randomDist = TRUE)
pts[,3] <- rep(z[1], 25)
ellipseStack <- pts
for(i in 2:length(x)){
pts <- matrix(NA, nrow = 25, ncol = 3)
pts[,1:2] <- calculateEllipse(x[i],y[i],a,a, steps = 25, randomDist = TRUE)
pts[,3] <- rep(z[i], 25)
ellipseStack <- rbind(ellipseStack, pts)
}
# plot3d(ellipseStack[,1], ellipseStack[,2], ellipseStack[,3], type = "s", size = 0.45)
aboutY <- function(phi) {matrix( c(cos(phi), 0, sin(phi), 0, 1, 0, -sin(phi), 0, cos(phi)), 3, 3)}
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
theta <- -runif(1,2,8)*pi/180 #rotate the coupon so it's almost upright to match the
#usual orientation of the actual coupons. Works better with nls too
Ry <- aboutY(theta)
turnedStack <- ellipseStack %*% Ry
# open3d()
# plot3d(turnedStack[,1], turnedStack[,2], turnedStack[,3], type = "s", size = 0.45)
## ----------------------------------------------------------------------
## modified version of nlsCouponFit.R
## removed while loop--since the radius of the ellipse is set,
## nls finds the optimal orientation quite fast and there's zero
## distance between the ellipse points and the target radius,
## casuing the step size to be reduced past minimum threshold
## ----------------------------------------------------------------------
deciles <- quantile(turnedStack[,3], prob = seq(0, 1, length = 11), type = 5)
comX <- turnedStack[,1]
comY <- turnedStack[,2]
comZ <- turnedStack[,3]
## subset the coupon to avoid the weld/support material remnants
good <- (comZ >= deciles[3] & comZ <= deciles[9])
poreCoordinates <- cbind( comX,
comY,
comZ)
oldCoupon <- poreCoordinates # to save the orginial coords for 3d plotting
## get centers of mass for upper and lower half of the coupon to
## compute axisVector, which is the direction vector for
## the initial axis estimate
upperHalf <- (comZ >= deciles[6]) & good
lowerHalf <- (comZ <= deciles[6]) & good
axisVector <- colMeans(poreCoordinates[upperHalf,]) - colMeans(poreCoordinates[lowerHalf,])
axisVector <- axisVector / sqrt(sum(axisVector^2)) # make it unit length
poreCoordinates <- cbind( comX[good],
comY[good],
comZ[good])
## project the centroid into the x-y plane along axisVector.
## allows us the parameterize the centroid using two parameters
## (x,y,0) rather than three (x,y,z)
centroid <- colMeans(poreCoordinates)
xyCentroid <- c( (axisVector[1]*-centroid[3])/axisVector[3] + centroid[1],
(axisVector[2]*-centroid[3])/axisVector[3] + centroid[2],
0)
## initial radius guess
r = 1000 # based on ideal coupon radius of 1000 micor-meters
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("alignCoupon.R")
source("radiusAligned.R")
N <- length(poreCoordinates[,1])
radiusTarget <- rep(r, N)
centerAxis <- nls(radiusTarget~radiusAligned(poreCoordinates, centroidX, centroidY, axisVectorX, axisVectorY),
start = list(centroidX = xyCentroid[1], centroidY = xyCentroid[2],
axisVectorX = axisVector[1], axisVectorY = axisVector[2]),
control = nls.control(minFactor = 1/5500))
nlsCoeff <- coef(centerAxis)
## store the old coupon coordinates, the "new" rotated coupon coords, and the nls coeff
## useful for generating surface plots and histograms for each coupon
source("newCoupon.R")
setwd("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData")
newCoupon <- newCoupon(poreCoordinates, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
save(oldCoupon, newCoupon, nlsCoeff, file = paste0(round(l,3),"spacingSyn0.rda"))
}
source('~/Coupons/layers/0degreeSlice/makeTestCoupon0.R', echo=TRUE)
source('~/Coupons/layers/0degreeSlice/testLayers0.R', echo=TRUE)
saveRDS(harmonicSignals, "synthetic0layers.rds")
harmonicSignals[order(harmonicSignals)]
source('~/Coupons/layers/0degreeSlice/nullHypothesis0.R', echo=TRUE)
saveRDS(harmonicSignalsNull, "harmonicSignalsNull.rds")
library(pracma)
library(rgl)
library(fields)
library(FSA)
setwd("C:/Users/barna/Documents/Coupons/layers/45degreeSlice")
source("threshold.R")
source("45degreeFunctions.R")
setwd("C:/Users/barna/Documents/Coupons/nlsAxis/datasets")
load("couponCov.rda")
setwd("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData")
harmonicSignalsNull <- readRDS("harmonicSignalsNull.rds")
setwd("C:/Users/barna/Documents/Coupons/nlsAxis/couponCaseStudies/caseStudyData/cropped")
Zero <- which(couponCov$polarAngle == 0)
numCoupons <- length(Zero)
realSignals <- vector()
for(n in Zero){
print(n)
load(paste0("nlsCoupon", n, ".rda"))
# center the coupon
centerCoupon <- cbind(scale(newCoupon[,1], center = TRUE, scale = FALSE),
scale(newCoupon[,2], center = TRUE, scale = FALSE),
newCoupon[,3])
h<-hist(~newCoupon[,3], w=5, plot = FALSE)
histSave <- rbind(h$counts, h$mids)
threshold <- 5
influence <- 0
xGrid <- seq(min(histSave[2,]), max(histSave[2,]), length.out = length(histSave[1,]))
lowpass <- splint(histSave[2,], histSave[1,], xGrid, lambda = 50)
frDt <- fft(histSave[1,]-lowpass)
Dtlen <- length(histSave[1,])
Fr <- (1:Dtlen/Dtlen)[1:(Dtlen/2)]
P <- (Mod(2*frDt/Dtlen)^2)[1:(Dtlen/2)]
plot(Fr,P,type="l", main = paste0(n))
lag <- length(Fr)/10
peak <- findFreq(P,lag,threshold,influence)
ind <- which(peak$signals==1)
Ppeaks <- P[ind]
Frpeaks <- Fr[ind]
# fundFreq <- Frpeaks[which.max(Ppeaks)]
# findHarmonic <- vector()
#
#
# ##check for lowest freq (i.e. fundamental frequency)
#
# for(j in c(1/4,1/3,1/2,2,3,4,5)){
#   for(i in 1:length(Frpeaks)){
#     ifelse(all.equal(fundFreq*j, Frpeaks[i], tol = 0.01)==TRUE,  fundFreq <- c(fundFreq,Frpeaks[i]),  NA)
#   }
# }
#
# xline(fundFreq, col = "grey", lty=3)
#
# fundFreq <- min(fundFreq)
#
# xline(fundFreq, col = "violetred1", lty=3)
#
# ##find the harmonics
# for(j in 1:5){
#   for(i in 1:length(Fr)){
#     ifelse(all.equal(fundFreq*j, Fr[i], tol = 0.01)==TRUE,  findHarmonic <- c(findHarmonic, P[i]),  NA)
#   }
# }
findHarmonic <- vector()
origFreq <- Frpeaks[which.max(Ppeaks)]
for(j in c(1,1/2,1/3,1/4,1/5)){
fundFreq <- origFreq*j
if(fundFreq <= .15){break}
}
xline(fundFreq*c(1,2,3,4,5), col = "tomato", lty=3)
##find the harmonics
for(j in 1:5){
for(i in 1:length(Fr)){
ifelse(all.equal(fundFreq*j, Fr[i], tol = 0.05)==TRUE, findHarmonic <- c(findHarmonic, P[i]),  NA)
}
}
realSignals <- c(realSignals, sum(findHarmonic)/sum(P))
}
layeredCoupons <- harmonicSignals
nullCoupons <- c(harmonicSignalsNull, rep(NA, length(layeredCoupons)-length(harmonicSignalsNull)))
realCoupons <- c(realSignals, rep(NA, (length(nullCoupons)-length(realSignals))))
dat <- cbind(nullCoupons, realCoupons)
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
source('~/Coupons/layers/0degreeSlice/nullHypothesis0.R', echo=TRUE)
saveRDS(harmonicSignalsNull, "harmonicSignalsNull.rds")
setwd("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData/nullHyp")
harmonicSignalsNull <- readRDS("harmonicSignalsNull.rds")
setwd("C:/Users/barna/Documents/Coupons/nlsAxis/couponCaseStudies/caseStudyData/cropped")
layeredCoupons <- harmonicSignals
nullCoupons <- c(harmonicSignalsNull, rep(NA, length(layeredCoupons)-length(harmonicSignalsNull)))
realCoupons <- c(realSignals, rep(NA, (length(nullCoupons)-length(realSignals))))
dat <- cbind(nullCoupons, realCoupons)
dev.off()
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
#dev.off()
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
dat <- cbind(dat, layeredCoupons)
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
which.min(harmonicSignals)
for(l in numLayer[148]){
z = seq(0,4000,by = l)
y = rep(0, length(z))
x = y
a = 814  #radius
pts <- matrix(NA, nrow = 25, ncol = 3)
pts[,1:2] <- calculateEllipse(x[1],y[1],a,a, steps = 25, randomDist = TRUE)
pts[,3] <- rep(z[1], 25)
ellipseStack <- pts
for(i in 2:length(x)){
pts <- matrix(NA, nrow = 25, ncol = 3)
pts[,1:2] <- calculateEllipse(x[i],y[i],a,a, steps = 25, randomDist = TRUE)
pts[,3] <- rep(z[i], 25)
ellipseStack <- rbind(ellipseStack, pts)
}
# plot3d(ellipseStack[,1], ellipseStack[,2], ellipseStack[,3], type = "s", size = 0.45)
aboutY <- function(phi) {matrix( c(cos(phi), 0, sin(phi), 0, 1, 0, -sin(phi), 0, cos(phi)), 3, 3)}
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
theta <- -runif(1,2,8)*pi/180 #rotate the coupon so it's almost upright to match the
#usual orientation of the actual coupons. Works better with nls too
Ry <- aboutY(theta)
turnedStack <- ellipseStack %*% Ry
# open3d()
# plot3d(turnedStack[,1], turnedStack[,2], turnedStack[,3], type = "s", size = 0.45)
## ----------------------------------------------------------------------
## modified version of nlsCouponFit.R
## removed while loop--since the radius of the ellipse is set,
## nls finds the optimal orientation quite fast and there's zero
## distance between the ellipse points and the target radius,
## casuing the step size to be reduced past minimum threshold
## ----------------------------------------------------------------------
deciles <- quantile(turnedStack[,3], prob = seq(0, 1, length = 11), type = 5)
comX <- turnedStack[,1]
comY <- turnedStack[,2]
comZ <- turnedStack[,3]
## subset the coupon to avoid the weld/support material remnants
good <- (comZ >= deciles[3] & comZ <= deciles[9])
poreCoordinates <- cbind( comX,
comY,
comZ)
oldCoupon <- poreCoordinates # to save the orginial coords for 3d plotting
## get centers of mass for upper and lower half of the coupon to
## compute axisVector, which is the direction vector for
## the initial axis estimate
upperHalf <- (comZ >= deciles[6]) & good
lowerHalf <- (comZ <= deciles[6]) & good
axisVector <- colMeans(poreCoordinates[upperHalf,]) - colMeans(poreCoordinates[lowerHalf,])
axisVector <- axisVector / sqrt(sum(axisVector^2)) # make it unit length
poreCoordinates <- cbind( comX[good],
comY[good],
comZ[good])
## project the centroid into the x-y plane along axisVector.
## allows us the parameterize the centroid using two parameters
## (x,y,0) rather than three (x,y,z)
centroid <- colMeans(poreCoordinates)
xyCentroid <- c( (axisVector[1]*-centroid[3])/axisVector[3] + centroid[1],
(axisVector[2]*-centroid[3])/axisVector[3] + centroid[2],
0)
## initial radius guess
r = 1000 # based on ideal coupon radius of 1000 micor-meters
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("alignCoupon.R")
source("radiusAligned.R")
N <- length(poreCoordinates[,1])
radiusTarget <- rep(r, N)
centerAxis <- nls(radiusTarget~radiusAligned(poreCoordinates, centroidX, centroidY, axisVectorX, axisVectorY),
start = list(centroidX = xyCentroid[1], centroidY = xyCentroid[2],
axisVectorX = axisVector[1], axisVectorY = axisVector[2]),
control = nls.control(minFactor = 1/5500))
nlsCoeff <- coef(centerAxis)
## store the old coupon coordinates, the "new" rotated coupon coords, and the nls coeff
## useful for generating surface plots and histograms for each coupon
source("newCoupon.R")
setwd("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData")
newCoupon <- newCoupon(poreCoordinates, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
save(oldCoupon, newCoupon, nlsCoeff, file = paste0(round(l,3),"spacingSyn0.rda"))
}
for(n in layerSpacing[148]){
print(round(n,3))
load(paste0(round(n,3),"spacingSyn0.rda"))
#load("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData/nullHyp/50spacingRep5.rda")
# center the coupon
centerCoupon <- cbind(scale(newCoupon[,1], center = TRUE, scale = FALSE),
scale(newCoupon[,2], center = TRUE, scale = FALSE),
newCoupon[,3])
h<-hist(~newCoupon[,3], w=5, plot = FALSE)
histSave <- rbind(h$counts, h$mids)
threshold <- 10
influence <- 0
xGrid <- seq(min(histSave[2,]), max(histSave[2,]), length.out = length(histSave[1,]))
lowpass <- splint(histSave[2,], histSave[1,], xGrid, lambda = 50)
frDt <- fft(histSave[1,]-lowpass)
Dtlen <- length(histSave[1,])
Fr <- (1:Dtlen/Dtlen)[1:(Dtlen/2)]
P <- (Mod(2*frDt/Dtlen)^2)[1:(Dtlen/2)]
plot(Fr,P,type="l", main = paste0("layer spacing at ", round(n,3)))
lag <- length(Fr)/10
peak <- findFreq(P,lag,threshold,influence)
ind <- which(peak$signals==1)
Ppeaks <- P[ind]
Frpeaks <- Fr[ind]
#fundFreq <- Frpeaks[which.max(Ppeaks)]
#fundFreq <- Fr[which.max(P[which(Fr<=0.15)])]
findHarmonic <- vector()
origFreq <- Frpeaks[which.max(Ppeaks)]
for(j in c(1,1/2,1/3,1/4,1/5)){
fundFreq <- origFreq*j
if(fundFreq <= .15){break}
}
xline(fundFreq*c(1,2,3,4,5), col = "tomato", lty=3)
##check for lowest freq (i.e. fundamental frequency)
# for(j in c(1/5,1/4,1/3,1/2,2,3,4,5)){
#   for(i in 1:length(Frpeaks)){
#     ifelse(all.equal(fundFreq*j, Frpeaks[i], tol = 0.05)==TRUE,  fundFreq <- c(fundFreq,Frpeaks[i]),  NA)
#   }
# }
# xline(Frpeaks, col="steelblue", lty=3)
# fundFreq <- min(fundFreq)
# xline(fundFreq*c(1,2,3,4,5), col = "grey", lty=3)
# xline(min(Frpeaks), col = "cornflowerblue", lty=3)
#
# fundFreq <- min(fundFreq)
#
# xline(fundFreq*c(1,2,3,4), col = "violetred1", lty=3)
#
##find the harmonics
for(j in 1:5){
for(i in 1:length(Fr)){
ifelse(isTRUE(all.equal(fundFreq*j, Fr[i], tol = 0.05)), findHarmonic <- c(findHarmonic, P[i]),  NA)
}
}
#xline(Frpeaks[c(4,5,6,7,9,10,11,12)], col="grey", lty=3)
#findHarmonic <- c(findHarmonic, Ppeaks[i])
harmonicSignals[k] <- sum(findHarmonic)/sum(P)
k=k+1
}
setwd("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData")
for(n in layerSpacing[148]){
print(round(n,3))
load(paste0(round(n,3),"spacingSyn0.rda"))
#load("C:/Users/barna/Documents/Coupons/layers/0degreeSlice/0degreeData/nullHyp/50spacingRep5.rda")
# center the coupon
centerCoupon <- cbind(scale(newCoupon[,1], center = TRUE, scale = FALSE),
scale(newCoupon[,2], center = TRUE, scale = FALSE),
newCoupon[,3])
h<-hist(~newCoupon[,3], w=5, plot = FALSE)
histSave <- rbind(h$counts, h$mids)
threshold <- 10
influence <- 0
xGrid <- seq(min(histSave[2,]), max(histSave[2,]), length.out = length(histSave[1,]))
lowpass <- splint(histSave[2,], histSave[1,], xGrid, lambda = 50)
frDt <- fft(histSave[1,]-lowpass)
Dtlen <- length(histSave[1,])
Fr <- (1:Dtlen/Dtlen)[1:(Dtlen/2)]
P <- (Mod(2*frDt/Dtlen)^2)[1:(Dtlen/2)]
plot(Fr,P,type="l", main = paste0("layer spacing at ", round(n,3)))
lag <- length(Fr)/10
peak <- findFreq(P,lag,threshold,influence)
ind <- which(peak$signals==1)
Ppeaks <- P[ind]
Frpeaks <- Fr[ind]
#fundFreq <- Frpeaks[which.max(Ppeaks)]
#fundFreq <- Fr[which.max(P[which(Fr<=0.15)])]
findHarmonic <- vector()
origFreq <- Frpeaks[which.max(Ppeaks)]
for(j in c(1,1/2,1/3,1/4,1/5)){
fundFreq <- origFreq*j
if(fundFreq <= .15){break}
}
xline(fundFreq*c(1,2,3,4,5), col = "tomato", lty=3)
##check for lowest freq (i.e. fundamental frequency)
# for(j in c(1/5,1/4,1/3,1/2,2,3,4,5)){
#   for(i in 1:length(Frpeaks)){
#     ifelse(all.equal(fundFreq*j, Frpeaks[i], tol = 0.05)==TRUE,  fundFreq <- c(fundFreq,Frpeaks[i]),  NA)
#   }
# }
# xline(Frpeaks, col="steelblue", lty=3)
# fundFreq <- min(fundFreq)
# xline(fundFreq*c(1,2,3,4,5), col = "grey", lty=3)
# xline(min(Frpeaks), col = "cornflowerblue", lty=3)
#
# fundFreq <- min(fundFreq)
#
# xline(fundFreq*c(1,2,3,4), col = "violetred1", lty=3)
#
##find the harmonics
for(j in 1:5){
for(i in 1:length(Fr)){
ifelse(isTRUE(all.equal(fundFreq*j, Fr[i], tol = 0.05)), findHarmonic <- c(findHarmonic, P[i]),  NA)
}
}
#xline(Frpeaks[c(4,5,6,7,9,10,11,12)], col="grey", lty=3)
#findHarmonic <- c(findHarmonic, Ppeaks[i])
harmonicSignals[k] <- sum(findHarmonic)/sum(P)
k=k+1
}
source('~/Coupons/layers/0degreeSlice/testLayers0.R', echo=TRUE)
source('~/Coupons/layers/0degreeSlice/testLayers0.R', echo=TRUE)
saveRDS(harmonicSignals, "synthetic0layers.rds")
layeredCoupons <- harmonicSignals
nullCoupons <- c(harmonicSignalsNull, rep(NA, length(layeredCoupons)-length(harmonicSignalsNull)))
realCoupons <- c(realSignals, rep(NA, (length(nullCoupons)-length(realSignals))))
dat <- cbind(nullCoupons, realCoupons)
#dev.off()
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
dat <- cbind(dat, layeredCoupons)
boxplot(dat, main = "relative peak strength, 0 degree coupons",
pch = 16, boxwex = 0.7)
t.test(nullCoupons, realCoupons)
t.test(harmonicSignals, realCoupons)
source('~/Coupons/layers/0degreeSlice/nullHypothesis0.R', echo=TRUE)
