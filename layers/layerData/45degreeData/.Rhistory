axisVector <- axisVector / sqrt(sum(axisVector^2)) # make it unit length
poreCoordinates <- cbind( comX[good],
comY[good],
comZ[good])
## project the centroid into the x-y plane along axisVector.
## allows us the parameterize the centroid using two parameters
## (x,y,0) rather than three (x,y,z)
centroid <- colMeans(poreCoordinates)
xyCentroid <- c( (axisVector[1]*-centroid[3])/axisVector[3] + centroid[1],
(axisVector[2]*-centroid[3])/axisVector[3] + centroid[2],
0)
## initial radius guess
r = 1000 # based on ideal coupon radius of 1000 micor-meters
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("rotateCoupon.R")
source("getRadius.R")
N <- length(poreCoordinates[,1])
radiusTarget <- rep(r, N)
centerAxis <- NULL
attempt <- 1
while( is.null(centerAxis) && attempt <= 10 ) {
print(l)
attempt <- attempt + 1
try(centerAxis <- nls(radiusTarget~radiusAligned(poreCoordinates, centroidX, centroidY, axisVectorX, axisVectorY),
start = list(centroidX = xyCentroid[1], centroidY = xyCentroid[2],
axisVectorX = axisVector[1], axisVectorY = axisVector[2]),
control = nls.control(minFactor = 1/10000000000000)))
}
nlsCoeff <- coef(centerAxis)
## store the old coupon coordinates, the "new" rotated coupon coords, and the nls coeff
## useful for generating surface plots and histograms for each coupon
source("newCoupon.R")
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/spacing40to60")
nlsCoupon <- newCoupon(poreCoordinates, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
save(oldCoupon, nlsCoupon, nlsCoeff, file = paste0(round(l,3),"spacingSyn45.rda"))
}
source('~/Coupons/layers/simulateCoupons/makeCoupon45.R', echo=TRUE)
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/spacing40to60")
inputFiles <- list.files(full.names = TRUE)
N <- length(inputFiles) #number of coupons in the sample size
TSFlayers <- rep(NA, N) #test statistic (TS), forty-five degree, layered
i = 1 #dummy index to increment TS
# load required function files
setwd("C:/Users/barna/Documents/Coupons/layers")
load("couponCov.rda")
source("calculateTestStatistic.R")
source("rotations.R")
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/spacing40to60")
inputFiles <- list.files(full.names = TRUE)
N <- length(inputFiles) #number of coupons in the sample size
angleSeq <- seq(0, 2*pi, length.out = 100) #increment by which we change rotation
TSFlayers <- rep(NA, N) #test statistic (TS), forty-five degree, layered
tempTS <- NA
i = 1 #dummy index to increment TS
for(coupon in inputFiles){
load(coupon)
TSmax = 0 #initialize max test statistic
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
}
TSFlayers[i] <- tempTS
i = i + 1
}
maxTS = 0 #initialize max test statistic
for(coupon in inputFiles){
load(coupon)
maxTS = 0 #initialize max test statistic
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
}
TSFlayers[i] <- tempTS
i = i + 1
}
boxplot(TSFlayers)
TSFlayers
i = 1 #dummy index to increment TS
for(coupon in inputFiles){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
print(tempTS)
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
}
TSFlayers[i] <- tempTS
i = i + 1
}
storeTS <- rep(NA, 100)
for(coupon in inputFiles[1]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
storeTS[m] <- tempTS
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
TSFlayers[i] <- tempTS
i = i + 1
}
plot(storeTS)
for(coupon in inputFiles[5]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
storeTS[m] <- tempTS
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
TSFlayers[i] <- tempTS
i = i + 1
}
plot(storeTS)
storeTS <- matrix(NA, nrol = 100, ncol = 5)
storeTS <- matrix(NA, nrow = 100, ncol = 5)
TSFlayers
storeTS <- matrix(NA, nrow = 100, ncol = 5)
i = 1 #dummy index to increment TS
for(coupon in inputFiles[1:5]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
storeTS[,m] <- tempTS
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
#TSFlayers[i] <- tempTS
i = i + 1
}
i = 1 #dummy index to increment TS
for(coupon in inputFiles[1:5]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
storeTS[i,m] <- tempTS
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
#TSFlayers[i] <- tempTS
i = i + 1
}
i = 1 #dummy index to increment TS
for(coupon in inputFiles[1:5]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
storeTS[m,i] <- tempTS
ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
#TSFlayers[i] <- tempTS
i = i + 1
}
plot(storeTS)
plot(storeTS[,1])
plot(storeTS[,2])
plot(storeTS[,3])
plot(storeTS[,4])
plot(storeTS[,5])
TSFlayers[1:5]
tempTS <- rep(NA,100)
tempTS <- rep(NA,100)
i = 1 #dummy index to increment TS
for(coupon in inputFiles[1:5]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS[m] <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
#storeTS[m,i] <- tempTS
#ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
#TSFlayers[i] <- tempTS
i = i + 1
}
i = 1 #dummy index to increment TS
for(coupon in inputFiles[1:5]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS[m] <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
#storeTS[m,i] <- tempTS
#ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
TSFtest[i] <- max(tempTS)
#TSFlayers[i] <- tempTS
i = i + 1
}
TSFtest <- rep(NA, 5)
i = 1 #dummy index to increment TS
for(coupon in inputFiles[1:5]){
load(coupon)
print(i)
maxTS = 0 #initialize max test statistic
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS[m] <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
#storeTS[m,i] <- tempTS
#ifelse((tempTS > maxTS), (maxTS = tempTS), NA) #see if TS is higher
m=m+1
}
TSFtest[i] <- max(tempTS)
#TSFlayers[i] <- tempTS
i = i + 1
}
TSFtest
inputFiles <- list.files(full.names = TRUE)
N <- length(inputFiles) #number of coupons in the sample size
angleSeq <- seq(0, 2*pi, length.out = 100) #increment by which we change rotation
tempTS <- rep(NA, 100) #store TS for each rotation
TSFlayers <- rep(NA, N) #test statistic (TS), forty-five degree, layered
i = 1 #dummy index to increment TS
for(coupon in inputFiles){
load(coupon)
print(i)
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS[m] <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
m=m+1
}
TSFlayers[i] <- max(tempTS)
i = i + 1
}
boxplot(TSFlayers)
numLayer <- seq(40,60,length.out = 100)
for(s in numLayer){
numPore <- length(seq(0,4000,by = s))
dense <- numPore*25 #find density of pores in layered version of coupon
for(l in 1:10){
# calc points on a 45 degree line
x = runif(dense, 0, 4000)
y = rep(0, length(x))
z = x
phi = 45*pi/180
a = 814*sec(phi) #major axis
b = 814 #minor axis
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[1],y[1],a,b, steps = 1, randomDist = TRUE)
pts[,3] <- z[1]
ellipseStack <- pts
for(i in 2:length(x)){
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[i],y[i],a,b, steps = 1, randomDist = TRUE)
pts[,3] <- z[i]
ellipseStack <- rbind(ellipseStack, pts)
}
#points3d(ellipseStack[,1], ellipseStack[,2], ellipseStack[,3], size = 4)
aboutY <- function(phi) {matrix( c(cos(phi), 0, sin(phi), 0, 1, 0, -sin(phi), 0, cos(phi)), 3, 3)}
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
theta <- -41*pi/180 #rotate the coupon so it's almost upright to match the
#usual orientation of the actual coupons. Works better with nls too
Ry <- aboutY(theta)
turnedStack <- ellipseStack %*% Ry
# points3d(turnedStack[,1], turnedStack[,2], turnedStack[,3], size = 4)
## ----------------------------------------------------------------------
## modified version of nlsCouponFit.R
## removed while loop--since the radius of the ellipse is set,
## nls finds the optimal orientation quite fast and there's zero
## distance between the ellipse points and the target radius,
## casuing the step size to be reduced past minimum threshold
## ----------------------------------------------------------------------
deciles <- quantile(turnedStack[,3], prob = seq(0, 1, length = 11), type = 5)
comX <- turnedStack[,1]
comY <- turnedStack[,2]
comZ <- turnedStack[,3]
## subset the coupon to avoid the weld/support material remnants
good <- (comZ >= deciles[3] & comZ <= deciles[9])
poreCoordinates <- cbind( comX,
comY,
comZ)
oldCoupon <- poreCoordinates # to save the orginial coords for 3d plotting
## get centers of mass for upper and lower half of the coupon to
## compute axisVector, which is the direction vector for
## the initial axis estimate
upperHalf <- (comZ >= deciles[6]) & good
lowerHalf <- (comZ <= deciles[6]) & good
axisVector <- colMeans(poreCoordinates[upperHalf,]) - colMeans(poreCoordinates[lowerHalf,])
axisVector <- axisVector / sqrt(sum(axisVector^2)) # make it unit length
poreCoordinates <- cbind( comX[good],
comY[good],
comZ[good])
## project the centroid into the x-y plane along axisVector.
## allows us the parameterize the centroid using two parameters
## (x,y,0) rather than three (x,y,z)
centroid <- colMeans(poreCoordinates)
xyCentroid <- c( (axisVector[1]*-centroid[3])/axisVector[3] + centroid[1],
(axisVector[2]*-centroid[3])/axisVector[3] + centroid[2],
0)
## initial radius guess
r = 1000 # based on ideal coupon radius of 1000 micor-meters
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("rotateCoupon.R")
source("getRadius.R")
N <- length(poreCoordinates[,1])
radiusTarget <- rep(r, N)
centerAxis <- NULL
attempt <- 1
while( is.null(centerAxis) && attempt <= 10 ) {
print(l)
attempt <- attempt + 1
try(centerAxis <- nls(radiusTarget~radiusAligned(poreCoordinates, centroidX, centroidY, axisVectorX, axisVectorY),
start = list(centroidX = xyCentroid[1], centroidY = xyCentroid[2],
axisVectorX = axisVector[1], axisVectorY = axisVector[2]),
control = nls.control(minFactor = 1/10000000000000)))
}
nlsCoeff <- coef(centerAxis)
## store the old coupon coordinates, the "new" rotated coupon coords, and the nls coeff
## useful for generating surface plots and histograms for each coupon
source("newCoupon.R")
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/noLayers")
nlsCoupon <- newCoupon(poreCoordinates, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
save(oldCoupon, nlsCoupon, nlsCoeff, file = paste0(round(s,3),"spacingRep",round(l,3),".rda"))
}
}
numLayer <- seq(40,60,length.out = 10)
for(s in numLayer){
numPore <- length(seq(0,4000,by = s))
dense <- numPore*25 #find density of pores in layered version of coupon
for(l in 1:10){
# calc points on a 45 degree line
x = runif(dense, 0, 4000)
y = rep(0, length(x))
z = x
phi = 45*pi/180
a = 814*sec(phi) #major axis
b = 814 #minor axis
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[1],y[1],a,b, steps = 1, randomDist = TRUE)
pts[,3] <- z[1]
ellipseStack <- pts
for(i in 2:length(x)){
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[i],y[i],a,b, steps = 1, randomDist = TRUE)
pts[,3] <- z[i]
ellipseStack <- rbind(ellipseStack, pts)
}
#points3d(ellipseStack[,1], ellipseStack[,2], ellipseStack[,3], size = 4)
aboutY <- function(phi) {matrix( c(cos(phi), 0, sin(phi), 0, 1, 0, -sin(phi), 0, cos(phi)), 3, 3)}
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
theta <- -41*pi/180 #rotate the coupon so it's almost upright to match the
#usual orientation of the actual coupons. Works better with nls too
Ry <- aboutY(theta)
turnedStack <- ellipseStack %*% Ry
# points3d(turnedStack[,1], turnedStack[,2], turnedStack[,3], size = 4)
## ----------------------------------------------------------------------
## modified version of nlsCouponFit.R
## removed while loop--since the radius of the ellipse is set,
## nls finds the optimal orientation quite fast and there's zero
## distance between the ellipse points and the target radius,
## casuing the step size to be reduced past minimum threshold
## ----------------------------------------------------------------------
deciles <- quantile(turnedStack[,3], prob = seq(0, 1, length = 11), type = 5)
comX <- turnedStack[,1]
comY <- turnedStack[,2]
comZ <- turnedStack[,3]
## subset the coupon to avoid the weld/support material remnants
good <- (comZ >= deciles[3] & comZ <= deciles[9])
poreCoordinates <- cbind( comX,
comY,
comZ)
oldCoupon <- poreCoordinates # to save the orginial coords for 3d plotting
## get centers of mass for upper and lower half of the coupon to
## compute axisVector, which is the direction vector for
## the initial axis estimate
upperHalf <- (comZ >= deciles[6]) & good
lowerHalf <- (comZ <= deciles[6]) & good
axisVector <- colMeans(poreCoordinates[upperHalf,]) - colMeans(poreCoordinates[lowerHalf,])
axisVector <- axisVector / sqrt(sum(axisVector^2)) # make it unit length
poreCoordinates <- cbind( comX[good],
comY[good],
comZ[good])
## project the centroid into the x-y plane along axisVector.
## allows us the parameterize the centroid using two parameters
## (x,y,0) rather than three (x,y,z)
centroid <- colMeans(poreCoordinates)
xyCentroid <- c( (axisVector[1]*-centroid[3])/axisVector[3] + centroid[1],
(axisVector[2]*-centroid[3])/axisVector[3] + centroid[2],
0)
## initial radius guess
r = 1000 # based on ideal coupon radius of 1000 micor-meters
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("rotateCoupon.R")
source("getRadius.R")
N <- length(poreCoordinates[,1])
radiusTarget <- rep(r, N)
centerAxis <- NULL
attempt <- 1
while( is.null(centerAxis) && attempt <= 10 ) {
print(l)
attempt <- attempt + 1
try(centerAxis <- nls(radiusTarget~radiusAligned(poreCoordinates, centroidX, centroidY, axisVectorX, axisVectorY),
start = list(centroidX = xyCentroid[1], centroidY = xyCentroid[2],
axisVectorX = axisVector[1], axisVectorY = axisVector[2]),
control = nls.control(minFactor = 1/10000000000000)))
}
nlsCoeff <- coef(centerAxis)
## store the old coupon coordinates, the "new" rotated coupon coords, and the nls coeff
## useful for generating surface plots and histograms for each coupon
source("newCoupon.R")
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/noLayers")
nlsCoupon <- newCoupon(poreCoordinates, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
save(oldCoupon, nlsCoupon, nlsCoeff, file = paste0(round(s,3),"spacingRep",round(l,3),".rda"))
}
}
source('~/Coupons/layers/simulateCoupons/makeCoupon45NoLayers.R', echo=TRUE)
source('~/Coupons/layers/simulateCoupons/makeCoupon45NoLayers.R', echo=TRUE)
source('~/Coupons/layers/simulateCoupons/makeCoupon45NoLayers.R', echo=TRUE)
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/noLayers")
inputFiles <- list.files(full.names = TRUE)
N <- length(inputFiles) #number of coupons in the sample size
angleSeq <- seq(0, 2*pi, length.out = 100) #increment by which we change rotation
tempTS <- rep(NA, 100) #store TS for each rotation
TSFnolayers <- rep(NA, N) #test statistic (TS), forty-five degree, not layered
i = 1 #dummy index to increment TS
i = 1 #dummy index to increment TS
for(coupon in inputFiles){
load(coupon)
print(i)
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS[m] <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
m=m+1
}
TSFnolayers[i] <- max(tempTS)
i = i + 1
}
boxplot(TSZnolayers)
boxplot(TSFnolayers)
boxplot(TSFnolayers, TSFlayers)
fortyFive <- which(couponCov$polarAngle==45)
setwd("C:/Users/barna/Documents/Coupons/nlsAxis/porosity/nlsPorosityData/cropped")
inputFiles <- list.files(full.names = TRUE)
fortyFive <- which(couponCov$polarAngle==45)
N <- length(inputFiles[fortyFive]) #number of coupons in the sample size
angleSeq <- seq(0, 2*pi, length.out = 100) #increment by which we change rotation
tempTS <- rep(NA, 100) #store TS for each rotation
TSFreal <- rep(NA, N) #test statistic (TS), forty-five degree, not layered
i = 1 #dummy index to increment TS
for(coupon in inputFiles){
load(coupon)
print(i)
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS[m] <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
m=m+1
}
TSFreal[i] <- max(tempTS)
i = i + 1
}
boxplot(TSFreal)
i = 1 #dummy index to increment TS
for(coupon in inputFiles[fortyFive]){
load(coupon)
print(i)
m = 1
for(w in angleSeq){
rotatedCoupon <- rotateFortyFive(w, nlsCoupon) #center and rotate the coupon
tempTS[m] <- getTestStatistic(rotatedCoupon) #calc TS for rotated coupon
m=m+1
}
TSFreal[i] <- max(tempTS)
i = i + 1
}
boxplot(TSFnolayers, TSFreal, TSFlayers)
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData")
saveRDS(TSFlayers, "TSFlayers.rds")
saveRDS(TSFnolayers, "TSFnoLayers.rds")
saveRDS(TSFreal, "TSFreal.rds")
source('~/Coupons/layers/testForLayers.R', echo=TRUE)
par(nfrow=c(1,2))
par(mfrow=c(1,2))
boxplot(TSZnolayers, TSZreal, TSZlayers)
boxplot(TSFnolayers, TSFreal, TSFlayers)
