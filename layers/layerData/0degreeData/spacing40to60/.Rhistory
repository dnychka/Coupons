axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000))
bootNlsCoef[i,] <- coef(nlsObj)
}
for(i in nsamples){
bootNlsCoef <- matrix(ncol = 4, nrow = length(nsamples), NA)
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
radiusTarget <- rep(globalMedian, N)
startValues <- getInitialParameters(bootCoupon)
nlsObj <- nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000))
bootNlsCoef[i,] <- coef(nlsObj)
}
gc()
library(conicfit)
library(rgl)
library(dplyr)
myDir <- "C:/Users/barna/Documents/Coupons/nlsAxis/uncertainty"
# load the sample simulated coupon
sampleCoupon <- readRDS(file.path(myDir, "/simulatedCouponInternalJitter.rds"))
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("initialParameters.R")
source("rotateCoupon.R")
source("getRadius.R")
source("newCoupon.R")
source("nlsAxisFit.R")
nlsObj <- nlsAxisFit(sampleCoupon)
nlsCoeff <- coef(nlsObj[[1]])
globalMedian <- median(nlsObj[[2]])
nlsCoupon <- newCoupon(sampleCoupon, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
nlsCouponZ <- nlsCoupon %*% aboutZ(pi)
plot(nlsObj[[2]][1:100], pch=20, col="violetred1")
points(r[1:100])
r <- sqrt(sampleCoupon[,1]^2 + sampleCoupon[,2]^2)
theta <- atan2(sampleCoupon[,2], sampleCoupon[,1])
points(r[1:100])
plot3d(sampleCoupon[,1], sampleCoupon[,2], sampleCoupon[,3], type = "s", size =0.45,
col = ifelse(sampleCoupon[,1] == sampleCoupon[1,1], "violetred1", "black"))
open3d()
plot3d(nlsCoupon[,1], nlsCoupon[,2], nlsCoupon[,3], type = "s", size = 0.45,
col = ifelse(nlsCoupon[,1] == nlsCoupon[1,1], "violetred1", "black"))
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
nlsCouponZ <- nlsCoupon %*% aboutZ(pi)
err <- sampleCoupon - nlsCouponZ #errors for optimized param.
nsamples = 1:10
for(i in nsamples){
bootNlsCoef <- matrix(ncol = 4, nrow = length(nsamples), NA)
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
radiusTarget <- rep(globalMedian, N)
startValues <- getInitialParameters(bootCoupon)
nlsObj <- nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000))
bootNlsCoef[i,] <- coef(nlsObj)
}
for(i in nsamples){
print(i)
bootNlsCoef <- matrix(ncol = 4, nrow = length(nsamples), NA)
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
radiusTarget <- rep(globalMedian, N)
startValues <- getInitialParameters(bootCoupon)
nlsObj <- nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000))
bootNlsCoef[i,] <- coef(nlsObj)
}
for(i in nsamples){
print(i)
bootNlsCoef <- matrix(ncol = 4, nrow = length(nsamples), NA)
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
radiusTarget <- rep(globalMedian, N)
startValues <- getInitialParameters(bootCoupon)
nlsObj <- nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000))
bootNlsCoef[i,] <- coef(nlsObj)
}
nlsObj <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
nlsObj <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
nlsObj <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
nlsObj <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
?tryCatch
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
bootCoupon <- nlsCouponZ + bootErr
nlsObj <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
class(nlsObj)
?doStuff
nlsObj <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
bootCoupon <- nlsCouponZ + bootErr
nlsObj <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
class(nlsObj)
tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
nlsObjT <- tryCatch(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
class(nlsObjT)
nlsObjT <- try(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
nlsObjT
class(nlsObjT)
j = 1
while(j < 10){ #try nls up to 100 times
nlsObj <- try(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
if(class(nlsObj) != "try-error") j <- j + 1
}
nsamples = 1:10
for(i in nsamples){
print(i)
bootNlsCoef <- matrix(ncol = 4, nrow = length(nsamples), NA)
j = 1
while(j < 10){ #try nls up to 10 times
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
radiusTarget <- rep(globalMedian, N)
startValues <- getInitialParameters(bootCoupon)
nlsObj <- try(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
if(class(nlsObj) != "try-error") j <- j + 1
bootNlsCoef[i,] <- coef(nlsObj)
}
}
for(i in nsamples){
print(i)
bootNlsCoef <- matrix(ncol = 4, nrow = length(nsamples), NA)
j = 1
while(j < 10){ #try nls up to 10 times
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
radiusTarget <- rep(globalMedian, N)
startValues <- getInitialParameters(bootCoupon)
nlsObj <- try(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
if(class(nlsObj) != "try-error") j <- j + 1
}
bootNlsCoef[i,] <- coef(nlsObj)
}
bootNlsCoef
for(i in nsamples){
print(i)
j = 1
while(j < 10){ #try nls up to 10 times
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
radiusTarget <- rep(globalMedian, N)
startValues <- getInitialParameters(bootCoupon)
nlsObj <- try(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
if(class(nlsObj) != "try-error"){
j <- j + 1
bootNlsCoef[i,] <- coef(nlsObj)
}
}
}
bootNlsCoef
nsamples = 1:1000
bootNlsCoef <- matrix(ncol = 4, nrow = length(nsamples), NA)
for(i in nsamples){
print(i)
j = 1
while(j < 10){ #try nls up to 10 times
# resample from nlsRes using non-parametric sample to get
# new error values for every pore location
bootErr <- err[sample(nrow(err),size=length(err[,1]),replace=TRUE),]
# fabricate new data by adding the sampled errors to the
# model output
bootCoupon <- nlsCouponZ + bootErr
# estimate the parameter values for each new fabricated data set
N <- length(bootCoupon[,1])
# optimize to the median found in first optimization
radiusTarget <- rep(globalMedian, N) # no iterations here
startValues <- getInitialParameters(bootCoupon)
nlsObj <- try(nls(radiusTarget~radiusAligned(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY),
start = list(centroidX = startValues[2,1],
centroidY = startValues[2,2],
axisVectorX = startValues[1,1],
axisVectorY = startValues[1,2]),
control =  nls.control(minFactor = 1/100000000000000)))
if(class(nlsObj) != "try-error"){
j <- j + 1
bootNlsCoef[i,] <- coef(nlsObj)
}
} #end of while loop
} #end of for loop
bootNlsCoef
hist(bootNlsCoef[,1])
hist(bootNlsCoef[,2])
hist(bootNlsCoef[,3])
hist(bootNlsCoef[,4])
setwd("~/Coupons/nlsAxis/uncertainty")
saveRDS(bootNlsCoef, "bootNlsCoef.rds")
library(astsa)
library(fields)
library(FSA)
# load required function files
setwd("C:/Users/barna/Documents/Coupons/layers/layerFunctions")
load("couponCov.rda")
source("calculateTestStatistic.R")
source("rotations.R")
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/spacing40to60")
inputFiles <- list.files(full.names = TRUE)
N <- length(inputFiles) #number of coupons in the sample size
TSZlayers <- rep(NA, N) #test statistic (TS), zero degree, layers
source('~/Coupons/layers/testForLayers.R', echo=TRUE)
library(scales)
library(FSA)
library(astsa)
library(fields)
## -------------------------------
## TS boxplot for 0 degree coupons
## --------------------------------
TSZlayers <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/TSZlayers.rds")
TSZnolayers <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/TSZnolayers.rds")
TSZreal <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/TSZreal.rds")
TSZreal <- c(TSZreal, rep(NA, 100-16))
zerosAll <- cbind(TSZnolayers, TSZreal, TSZlayers)
colnames(zerosAll) <- c("no layers", "experimental", "layered")
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", cex.lab = 1.2)
boxplot(zerosAll,
ylab = "test statistic", xlab = "coupon populations",
cex.lab = 1.2, family = "A",
pch = 20, boxlwd = 2, boxwex = 0.5,
ylim = c(0,1))
mtext("Distribution of Test Statistic, 0 degree Coupons",
side=3, adj=0, line=1.6, cex=1.4, font=2, family = "A")
## --------------------------------
## TS boxplot for 45 degree coupons
## --------------------------------
TSFlayers <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/TSFlayers.rds")
TSFnolayers <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/TSFnolayers.rds")
TSFreal <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/45degreeData/TSFreal.rds")
TSFreal <- c(TSFreal, rep(NA, 100-24))
colnames(ffAll) <- c("no layers", "experimental", "layered")
ffAll <- cbind(TSFnolayers, TSFreal, TSFlayers)
windowsFonts(A = windowsFont("Times New Roman"))
ffAll <- cbind(TSFnolayers, TSFreal, TSFlayers)
colnames(ffAll) <- c("no layers", "experimental", "layered")
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", cex.lab = 1.2)
boxplot(ffAll,
ylab = "test statistic", xlab = "coupon populations",
cex.lab = 1.2, family = "A",
pch = 20, boxlwd = 2, boxwex = 0.5,
ylim = c(0,1))
mtext("Distribution of Test Statistic, 45 degree Coupons",
side=3, adj=0, line=1.6, cex=1.4, font=2, family = "A")
TSZlayers <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/TSZlayers.rds")
TSZnoise <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/noisySpacing40to60/TSZnoise.rds")
TSZreal <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/TSZreal.rds")
allNoise <- cbind(TSZlayers, TSZnoise, c(TSZreal, rep(NA, 100-16)))
boxplot(allNoise)
## ---------------------------------------------------------------------------------
## CREATE EXAMPLE PERIODOGRAMS
## ---------------------------------------------------------------------------------
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/spacing40to60")
inputFiles <- list.files(full.names = TRUE)
which(inputFiles=="./54.141spacingSyn0.rda")
for(coupon in inputFiles[99]){
load(coupon)
h <- hist(~nlsCoupon[,3], w=5, plot = FALSE)
counts <- h$counts
coords <- h$mids
# detrend the series using a spline
xGrid <- seq(min(coords), max(coords), length.out = length(coords))
highpass <- splint(coords, counts, xGrid, lambda = 50) #lambda set to be very smooth
detrendedData <- counts - highpass
# calculate the dft and compute raw periodogram using mvspec(.)
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", cex.lab = 1.2)
P <- mvspec(detrendedData, log='no', main = "", col = "black", sub="", ylim = c(0,51.5))
mtext("Periodogram for Layered Coupon",
side=3, adj=0, line=1.6, cex=1.4, font=2, family = "A")
# size: 679x522
}
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/noLayers")
inputFiles <- list.files(full.names = TRUE)
for(coupon in inputFiles[8]){
load(coupon)
h <- hist(~nlsCoupon[,3], w=5, plot = FALSE)
counts <- h$counts
coords <- h$mids
# detrend the series using a spline
xGrid <- seq(min(coords), max(coords), length.out = length(coords))
highpass <- splint(coords, counts, xGrid, lambda = 50) #lambda set to be very smooth
detrendedData <- counts - highpass
# calculate the dft and compute raw periodogram using mvspec(.)
windowsFonts(A = windowsFont("Times New Roman"))
par(family = "A", cex.lab = 1.2)
P <- mvspec(detrendedData, log='no', main = "", col = "black", sub="", ylim = c(0,51.5))
mtext("Periodogram for Non-Layered Coupon",
side=3, adj=0, line=1.6, cex=1.4, font=2, family = "A")
}
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/spacing40to60")
inputFiles <- list.files(full.names = TRUE)
for(coupon in inputFiles){
load(coupon)
load("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/spacing40to60/56.162spacingSyn0.rda")
#create series data (count values for hist bins)
h <- hist(~nlsCoupon[,3], w=5, plot = FALSE)
counts <- h$counts
coords <- h$mids
# detrend the series using a spline
xGrid <- seq(min(coords), max(coords), length.out = length(coords))
highpass <- splint(coords, counts, xGrid, lambda = 50) #lambda set to be very smooth
detrendedData <- counts - highpass
# calculate the dft and compute smoothed periodogram using mvspec(.)
P <- mvspec(detrendedData, kernel('daniell',2), log='no', main = "", col = "grey40")
mtext("Smoothed Periodogram with Peak Detection",
side=3, adj=0, line=1.6, cex=1.4, font=2, family = "A")
#P <- mvspec(detrendedData)
# calculate lower bounds of 95% confidence intervals for each
# periodogram ordinate
df = P$df
L = qchisq(.975, df)
U = qchisq(.025, df)
n = length(P$freq)
lowerBound <- rep(NA, n)
upperBound <- rep(NA, n)
for(i in 1:n){
lowerBound[i] <- df*P$spec[i]/L
upperBound[i] <- df*P$spec[i]/U
}
# points(P$freq, upperBound, pch = 20, col = "tomato")
# lines(P$freq, lowerBound, col = "cornflowerblue", lwd = 2)
points(P$freq, lowerBound, pch = 20, col = "cornflowerblue")
# establish baseline for periodogram using linear model
baseline <- lm(P$spec ~ P$freq)
lines(P$freq, baseline$fitted.values, col = "tomato", lwd = 2)
N = length(P$freq)
# get standard errors at each fitted value
pred <- predict(baseline, se.fit = TRUE)
SE <- pred$se.fit
zB <- qnorm(.025/N, lower.tail = FALSE)
xg <- c(P$freq,P$freq[N:1])
yg <- c(baseline$fitted.values - zB*SE,(baseline$fitted.values + zB*SE)[N:1])
polygon( xg, yg, border="grey",col=alpha("magenta",.1))
polygon( xg, yg, border="grey",col=alpha("tomato",.3))
legend("topright", legend = "baseline",
col = c("tomato"), lty = c(1),lwd = 3,inset = 0.05)
# find peaks in periodogram
peaks <- which(lowerBound > baseline$fitted.values)
# calculate test statistic
print(sum(P$spec[peaks])/sum(P$spec))
}
