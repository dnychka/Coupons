TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerDat, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
TSZnoLayerDat <- cbind(c(TSZnoLayers[1:20]), rep(1, 20))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerDat, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
TSZnoLayerDat <- cbind(c(TSZnoLayers), rep(1, 100))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerDat, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
TSZnoLayerEx <- TSZnoLayers[order(TSZnoLayers)][1:20]
TSZnoLayerEx
TSZnoLayerEx <- c(TSZnoLayers[order(TSZnoLayers)][1:20], rep(1, 20))
dat <- rbind(TSZnoLayerEx, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
TSZnoLayerEx <- cbind(TSZnoLayers[order(TSZnoLayers)][1:20], rep(1, 20))
TSZnoLayerDat <- cbind(c(TSZnoLayers), rep(1, 100))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerEx, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
TSZnoLayerEx <- cbind(TSZnoLayers[order(TSZnoLayers)][1:30], rep(1, 30))
TSZnoLayerDat <- cbind(c(TSZnoLayers), rep(1, 100))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerEx, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
geom_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
rhist<- hist(as.vector(TSZnoLayers), freq=F, xlim = c(0,0.8))
lhist <- hist(TSZlayers, freq=F, add=T)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
geom_density(alpha=0.3, kernel="gaussian", adjust=1, trim=T) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
TSZnoLayerEx <- cbind(TSZnoLayers[order(TSZnoLayers)][1:70], rep(1, 70))
TSZnoLayerDat <- cbind(c(TSZnoLayers), rep(1, 100))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerEx, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
geom_density(alpha=0.3, kernel="gaussian", adjust=1, trim=T) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
TSZnoLayerDat <- cbind(c(rep(TSZnoLayers, 20), rep(1, 2000))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
TSZnoLayerDat <- cbind(c(rep(TSZnoLayers, 20)), rep(1, 2000))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerEx, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
geom_density(alpha=0.3, kernel="gaussian", adjust=1, trim=T) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
geom_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
p2 <- ggplot(data.frame(TSZnoLayerDat), aes(TSZnoLayerDat[1]))
dat2 <- data.frame(TSZnoLayerDat)
p2 <- ggplot(dat, aes(X1))
p2
p2 <- ggplot(dat, aes(dat$X1)) + stat_density()
p2
TSZnoLayerDat <- cbind(TSZnoLayers, rep(1, 2000))
TSZnoLayerDat <- cbind(TSZnoLayers, rep(1, 10))
dat2 <- data.frame(TSZnoLayerDat)
p2 <- ggplot(dat2, aes(dat2$TSZnoLayers)) + stat_density()
p2
p
source('~/Coupons/layers/simulateCoupons/makeCoupon0NoLayers.R', echo=TRUE)
numLayer <- seq(60,100,length.out = 10)
for(l in numLayer){
numPore <- length(seq(0,4000,by = l))
dense <- numPore*25 #find density of pores in layered version of coupon
for(n in 1:10){ #reps for random repitition
z = runif(dense, 0, 4000)
y = rep(0, length(z))
x = y
centerAxis <- NULL
attempt <- 1
while( is.null(centerAxis) && attempt <= 10 ) {
print(l)
a = 814  #radius
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[1],y[1],a,a, steps = 1, randomDist = TRUE)
pts[,3] <- z[1]
ellipseStack <- pts
for(i in 2:length(x)){
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[i],y[i],a,a, steps = 1, randomDist = TRUE)
pts[,3] <- z[i]
ellipseStack <- rbind(ellipseStack, pts)
}
# open3d()
# plot3d(ellipseStack[,1], ellipseStack[,2], ellipseStack[,3], type = "s", size = 0.45,
#        zlab = "", xlab = "", ylab = "",
#        axes = FALSE)
# box3d(edges = "bbox", tick = FALSE, box = TRUE, col = "black")
#
aboutY <- function(phi) {matrix( c(cos(phi), 0, sin(phi), 0, 1, 0, -sin(phi), 0, cos(phi)), 3, 3)}
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
theta <- -8*pi/180 #rotate the coupon so it's almost upright to match the
#usual orientation of the actual coupons. Works better with nls too
Ry <- aboutY(theta)
turnedStack <- ellipseStack %*% Ry
#plot3d(turnedStack[,1], turnedStack[,2], turnedStack[,3], type = "s", size = 0.45)
## ----------------------------------------------------------------------
## modified version of nlsCouponFit.R
## removed while loop--since the radius of the ellipse is set,
## nls finds the optimal orientation quite fast and there's zero
## distance between the ellipse points and the target radius,
## casuing the step size to be reduced past minimum threshold
## ----------------------------------------------------------------------
deciles <- quantile(turnedStack[,3], prob = seq(0, 1, length = 11), type = 5)
comX <- turnedStack[,1]
comY <- turnedStack[,2]
comZ <- turnedStack[,3]
## subset the coupon to avoid the weld/support material remnants
good <- (comZ >= deciles[3] & comZ <= deciles[9])
poreCoordinates <- cbind( comX,
comY,
comZ)
oldCoupon <- poreCoordinates # to save the orginial coords for 3d plotting
## get centers of mass for upper and lower half of the coupon to
## compute axisVector, which is the direction vector for
## the initial axis estimate
upperHalf <- (comZ >= deciles[6]) & good
lowerHalf <- (comZ <= deciles[6]) & good
axisVector <- colMeans(poreCoordinates[upperHalf,]) - colMeans(poreCoordinates[lowerHalf,])
axisVector <- axisVector / sqrt(sum(axisVector^2)) # make it unit length
poreCoordinates <- cbind( comX[good],
comY[good],
comZ[good])
## project the centroid into the x-y plane along axisVector.
## allows us the parameterize the centroid using two parameters
## (x,y,0) rather than three (x,y,z)
centroid <- colMeans(poreCoordinates)
xyCentroid <- c( (axisVector[1]*-centroid[3])/axisVector[3] + centroid[1],
(axisVector[2]*-centroid[3])/axisVector[3] + centroid[2],
0)
## initial radius guess
r = 1000 # based on ideal coupon radius of 1000 micor-meters
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("rotateCoupon.R")
source("getRadius.R")
N <- length(poreCoordinates[,1])
radiusTarget <- rep(r, N)
attempt <- attempt + 1
try(centerAxis <- nls(radiusTarget~radiusAligned(poreCoordinates, centroidX, centroidY, axisVectorX, axisVectorY),
start = list(centroidX = xyCentroid[1], centroidY = xyCentroid[2],
axisVectorX = axisVector[1], axisVectorY = axisVector[2]),
control = nls.control(minFactor = 1/10000000000000)))
}
nlsCoeff <- coef(centerAxis)
## store the old coupon coordinates, the "new" rotated coupon coords, and the nls coeff
## useful for generating surface plots and histograms for each coupon
source("newCoupon.R")
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/noLayers")
nlsCoupon <- newCoupon(poreCoordinates, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
save(oldCoupon, nlsCoupon, nlsCoeff, file = paste0(round(l,3),"spacingRep",round(n,3),".rda"))
}
}
numLayer <- seq(61,100,length.out = 10)
for(l in numLayer){
numPore <- length(seq(0,4000,by = l))
dense <- numPore*25 #find density of pores in layered version of coupon
for(n in 1:10){ #reps for random repitition
z = runif(dense, 0, 4000)
y = rep(0, length(z))
x = y
centerAxis <- NULL
attempt <- 1
while( is.null(centerAxis) && attempt <= 10 ) {
print(l)
a = 814  #radius
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[1],y[1],a,a, steps = 1, randomDist = TRUE)
pts[,3] <- z[1]
ellipseStack <- pts
for(i in 2:length(x)){
pts <- matrix(NA, nrow = 1, ncol = 3)
pts[,1:2] <- calculateEllipse(x[i],y[i],a,a, steps = 1, randomDist = TRUE)
pts[,3] <- z[i]
ellipseStack <- rbind(ellipseStack, pts)
}
# open3d()
# plot3d(ellipseStack[,1], ellipseStack[,2], ellipseStack[,3], type = "s", size = 0.45,
#        zlab = "", xlab = "", ylab = "",
#        axes = FALSE)
# box3d(edges = "bbox", tick = FALSE, box = TRUE, col = "black")
#
aboutY <- function(phi) {matrix( c(cos(phi), 0, sin(phi), 0, 1, 0, -sin(phi), 0, cos(phi)), 3, 3)}
aboutZ <- function(theta) {matrix( c(cos(theta), sin(theta), 0, -sin(theta), cos(theta), 0, 0, 0, 1), 3, 3 )}
theta <- -8*pi/180 #rotate the coupon so it's almost upright to match the
#usual orientation of the actual coupons. Works better with nls too
Ry <- aboutY(theta)
turnedStack <- ellipseStack %*% Ry
#plot3d(turnedStack[,1], turnedStack[,2], turnedStack[,3], type = "s", size = 0.45)
## ----------------------------------------------------------------------
## modified version of nlsCouponFit.R
## removed while loop--since the radius of the ellipse is set,
## nls finds the optimal orientation quite fast and there's zero
## distance between the ellipse points and the target radius,
## casuing the step size to be reduced past minimum threshold
## ----------------------------------------------------------------------
deciles <- quantile(turnedStack[,3], prob = seq(0, 1, length = 11), type = 5)
comX <- turnedStack[,1]
comY <- turnedStack[,2]
comZ <- turnedStack[,3]
## subset the coupon to avoid the weld/support material remnants
good <- (comZ >= deciles[3] & comZ <= deciles[9])
poreCoordinates <- cbind( comX,
comY,
comZ)
oldCoupon <- poreCoordinates # to save the orginial coords for 3d plotting
## get centers of mass for upper and lower half of the coupon to
## compute axisVector, which is the direction vector for
## the initial axis estimate
upperHalf <- (comZ >= deciles[6]) & good
lowerHalf <- (comZ <= deciles[6]) & good
axisVector <- colMeans(poreCoordinates[upperHalf,]) - colMeans(poreCoordinates[lowerHalf,])
axisVector <- axisVector / sqrt(sum(axisVector^2)) # make it unit length
poreCoordinates <- cbind( comX[good],
comY[good],
comZ[good])
## project the centroid into the x-y plane along axisVector.
## allows us the parameterize the centroid using two parameters
## (x,y,0) rather than three (x,y,z)
centroid <- colMeans(poreCoordinates)
xyCentroid <- c( (axisVector[1]*-centroid[3])/axisVector[3] + centroid[1],
(axisVector[2]*-centroid[3])/axisVector[3] + centroid[2],
0)
## initial radius guess
r = 1000 # based on ideal coupon radius of 1000 micor-meters
setwd("C:/Users/barna/Documents/Coupons/nlsAxis")
source("rotateCoupon.R")
source("getRadius.R")
N <- length(poreCoordinates[,1])
radiusTarget <- rep(r, N)
attempt <- attempt + 1
try(centerAxis <- nls(radiusTarget~radiusAligned(poreCoordinates, centroidX, centroidY, axisVectorX, axisVectorY),
start = list(centroidX = xyCentroid[1], centroidY = xyCentroid[2],
axisVectorX = axisVector[1], axisVectorY = axisVector[2]),
control = nls.control(minFactor = 1/10000000000000)))
}
nlsCoeff <- coef(centerAxis)
## store the old coupon coordinates, the "new" rotated coupon coords, and the nls coeff
## useful for generating surface plots and histograms for each coupon
source("newCoupon.R")
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/noLayers")
nlsCoupon <- newCoupon(poreCoordinates, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
save(oldCoupon, nlsCoupon, nlsCoeff, file = paste0(round(l,3),"spacingRep",round(n,3),".rda"))
}
}
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/noLayers")
inputFiles <- list.files(full.names = TRUE)
N <- length(inputFiles) #number of coupons in the sample size
nsamples = 10
TSZlayers <- matrix(nrow = nsamples, ncol = 200, NA) #test statistic (TS), zero degree, not layered
l = 1 #dummy index to increment coupon number
for(coupon in inputFiles[1:200]){
load(coupon)
print(paste('*******', l, '*******'))
k = 1 #dummy index to increment TS
## model output from first round of nls
nlsTheta <- atan2(nlsCoupon[,2], nlsCoupon[,1])
nlsZ <- nlsCoupon[,3]
nlsR <- sqrt(nlsCoupon[,1]^2+nlsCoupon[,2]^2)
## begin the bootstrap for loop ------------
bootNlsCoef <- matrix(ncol = 5, nrow = length(nsamples), NA)
bootRadius <- matrix(ncol = length(nlsCoupon[,1]), nrow = length(nsamples), NA)
for(i in 1:nsamples){
print(i)
j = 1
while(j < 10){ #try nls up to 10 times
# generate stochastic data set by sampling possible
# thetas from uniform(0, 2pi)
bootTheta <- runif( length(nlsCoupon[,1]),0,2*pi)
# fabricate new data by adding the sampled errors to the
# model output
bootX <- nlsR*cos(bootTheta)
bootY <- nlsR*sin(bootTheta)
bootCoupon <- cbind(bootX, bootY, nlsZ)
# orient the bootCoupon so it matches the tilt in the
# original data; that way, nlsCoeff will match taking
# coupons from this original tilt -> alignment
bootCoupon <- getOldCoupon(bootCoupon, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
# estimate the parameter values for each new fabricated data set
M <- length(bootCoupon[,1])
startValues <- getInitialParameters(bootCoupon)
distTarget <- rep(0,M)
nlsObj <- try(nls(distTarget~getDistance(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY, r),
start = list(centroidX = startValues[4],
centroidY = startValues[5],
axisVectorX = startValues[1],
axisVectorY = startValues[2],
r = startValues[7]),
control =  nls.control(minFactor = 1/10000000000)))
if(class(nlsObj) != "try-error"){ # since nls needs babysitting
if(j == 1){
tempNlsCoeff <- coef(nlsObj)
tempCoupon <- newCoupon(bootCoupon, tempNlsCoeff["centroidX"], tempNlsCoeff["centroidY"],
tempNlsCoeff["axisVectorX"], tempNlsCoeff["axisVectorY"])
TSZlayers[k,l] <- getTestStatistic(tempCoupon)
k = k + 1
}
j <- j + 1
}
} #end of while loop
} #end of bootstrap for loop
# calculate the test statistic
l = l + 1
}
setwd("~/Coupons/layers/layerUncertainty")
saveRDS(TSZlayers, "TSZnolayersUncertainty.rds")
TSZlayers <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerUncertainty/TSZlayersUncertainty.rds")
TSZnolayers <- readRDS("C:/Users/barna/Documents/Coupons/layers/layerUncertainty/TSZnolayersUncertainty.rds")
TSZnoLayerDat <- cbind(as.vector(TSZnoLayers), rep(1, 2000))
TSZlayerDat <- cbind(as.vector(TSZlayers), rep(2,2000))
dat <- rbind(TSZnoLayerDat, TSZlayerDat)
dat <- data.frame(dat)
names(dat) <- c("signal", "type")
library(ggplot2)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=1.5) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="gaussian", adjust=2) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
hist(TSZnolayers)
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="rectangular", adjust=2) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="rectangular", adjust=2) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.0)
p
hist(TSZlayers)
hist(TSZnolayers)
hist(TSZlayers)
hist(TSZnoLayers, add=T)
hist(TSZlayers, freq=F)
hist(TSZnoLayers,freq=F, add=T)
hist(TSZnoLayers,freq=F, add=F)
hist(TSZnoLayers, freq=F, add=F, breaks=30)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="rectangular", adjust=2, legend = F) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.0)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="biweight", adjust=2) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", alpha = 0.0)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="biweight", adjust=2) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", col = "mediumturquoise", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="biweight", adjust=2) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", col = "firebrick", alpha = 0.4)
p
p <- ggplot(dat, aes(dat$signal, fill = as.factor(dat$type), col = as.factor(dat$type))) +
stat_density(alpha=0.3, kernel="biweight", adjust=2) +
geom_vline(data = data.frame(TSZrealPtEst),  aes(xintercept = TSZrealPtEst),
linetype="dashed", col = "mediumturquoise", alpha = 0.4)
p
hist(TSZlayers, freq=F)
setwd("C:/Users/barna/Documents/Coupons/layers/layerData/0degreeData/noLayers")
inputFiles <- list.files(full.names = TRUE)
N <- length(inputFiles) #number of coupons in the sample size
nsamples = 10
TSZlayers <- matrix(nrow = nsamples, ncol = 200, NA) #test statistic (TS), zero degree, not layered
l = 1 #dummy index to increment coupon number
for(coupon in inputFiles[1:200]){
load(coupon)
print(paste('*******', l, '*******'))
k = 1 #dummy index to increment TS
## model output from first round of nls
nlsTheta <- atan2(nlsCoupon[,2], nlsCoupon[,1])
nlsZ <- nlsCoupon[,3]
nlsR <- sqrt(nlsCoupon[,1]^2+nlsCoupon[,2]^2)
## begin the bootstrap for loop ------------
bootNlsCoef <- matrix(ncol = 5, nrow = length(nsamples), NA)
bootRadius <- matrix(ncol = length(nlsCoupon[,1]), nrow = length(nsamples), NA)
for(i in 1:nsamples){
print(i)
j = 1
while(j < 10){ #try nls up to 10 times
# generate stochastic data set by sampling possible
# thetas from uniform(0, 2pi)
bootTheta <- runif( length(nlsCoupon[,1]),0,2*pi)
# fabricate new data by adding the sampled errors to the
# model output
bootX <- nlsR*cos(bootTheta)
bootY <- nlsR*sin(bootTheta)
bootCoupon <- cbind(bootX, bootY, nlsZ)
# orient the bootCoupon so it matches the tilt in the
# original data; that way, nlsCoeff will match taking
# coupons from this original tilt -> alignment
bootCoupon <- getOldCoupon(bootCoupon, nlsCoeff["centroidX"], nlsCoeff["centroidY"],
nlsCoeff["axisVectorX"], nlsCoeff["axisVectorY"])
# estimate the parameter values for each new fabricated data set
M <- length(bootCoupon[,1])
startValues <- getInitialParameters(bootCoupon)
distTarget <- rep(0,M)
nlsObj <- try(nls(distTarget~getDistance(bootCoupon,
centroidX, centroidY,
axisVectorX, axisVectorY, r),
start = list(centroidX = startValues[4],
centroidY = startValues[5],
axisVectorX = startValues[1],
axisVectorY = startValues[2],
r = startValues[7]),
control =  nls.control(minFactor = 1/10000000000)))
if(class(nlsObj) != "try-error"){ # since nls needs babysitting
if(j == 1){
tempNlsCoeff <- coef(nlsObj)
tempCoupon <- newCoupon(bootCoupon, tempNlsCoeff["centroidX"], tempNlsCoeff["centroidY"],
tempNlsCoeff["axisVectorX"], tempNlsCoeff["axisVectorY"])
TSZlayers[k,l] <- getTestStatistic(tempCoupon)
k = k + 1
}
j <- j + 1
}
} #end of while loop
} #end of bootstrap for loop
# calculate the test statistic
l = l + 1
}
setwd("~/Coupons/layers/layerUncertainty")
saveRDS(TSZlayers, "TSZnolayersUncertainty2.rds")
gc()
